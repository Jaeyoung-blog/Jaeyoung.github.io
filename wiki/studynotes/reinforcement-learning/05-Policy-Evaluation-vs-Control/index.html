<!DOCTYPE html>
<html lang="ko">

<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png">
    

    <title>
        
          05. Policy Evaluation &amp; Control - Jaeyoung&#39;s Blog
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- theme css & js -->
    <link rel="stylesheet" href="/css/book.css">
    <script src="/js/book.js"></script>

    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

</head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>JAEYOUNG&#39;S BLOG</span>
  </a>
</div>
    <div class="book-menu">
  <ul>
<li><a href="/"><strong>Home</strong></a></li>
</ul>
<h1 id="Study-Notes"><strong>Study Notes</strong></h1>
<h2 id="Machine-Learning">Machine Learning</h2>
<ul>
<li><a href="/wiki/studynotes/machine-learning/Machine-Learning">Machine Learning</a></li>
<li><a href="/wiki/studynotes/machine-learning/KL-Divergence">KL Divergence</a></li>
<li><a href="/wiki/studynotes/machine-learning/Principal-Component-Analysis">Principal Component Analysis</a></li>
<li><a href="/wiki/studynotes/machine-learning/Restrict-Boltzmann-Machines-1">Restrict Boltzmann Machine 1</a></li>
<li><a href="/wiki/studynotes/machine-learning/Restrict-Boltzmann-Machines-2">Restrict Boltzmann Machine 2</a></li>
</ul>

</div>

<script src="/js/book-menu.js"></script>
  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1>Policy Evaluation &amp; Control</h1>
<p>참고: Coursera Reinforcement Learning (Alberta Univ.)</p>
<p>현재 가지고있는 policy가 좋은지 평가하고(evaluation) 더 좋은 policy로 향상시키는 작업(control)을 의미한다. 현재 가지고 있는 policy $\pi$와 dynamics of environment를 표현하는 $p(s’,r|s,a)$분포가 있으면, dynamic programming을 통해 value function을 계산해낼 수 있고, 그 value function을 이용해서 policy를 평가(evaluation)할 수 있다. 또한, dynamic programming을 통해 더 나은 policy를 찾을 수 있다(control).</p>
<p>Optimal policy를 찾기 위해서 policy evaluation과 control을 이용하게 된다.</p>
<h2 id="Policy-Evaluation">Policy Evaluation</h2>
<p>어떤 policy가 좋은지 평가하는 방법은 value function를 보는 것이 있겠다. Policy evaluation이란, 주어진 policy에 대해 value function을 구하는 것을 말한다.</p>
<p>임의의 policy를 하나 설정하고, 각 액션에 대해 immediate reward를 설정한 후에는 value function을 계산할 수 있을 것이다.</p>
<p><strong>어찌됬든 요약하면, policy evaluation은 그 policy를 이용한 value function을 계산하는 것을 말한다.</strong></p>
<p>주어진 policy에 대해 value function을 정확히 계산하기보단, approximation 방법을 이용한다.</p>
<h3 id="Iterative-Policy-Evaluation">Iterative Policy Evaluation</h3>
<p>주어진 policy를 이용하여 value function을 approximation하는 한 가지 방법으로, dynamic programming을 통한 iterative 방법이다. 처음에 모든 state의 value를 0으로(또는 임의의 아무 숫자) 초기화시킨 후, state-Bellman equation을 통해 모든 state의 value를 수렴할때까지 업데이트하게 된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterative_policy_evaluation</span><span class="params">(policy, p, states, threshold=<span class="number">1e-3</span>)</span>:</span></span><br><span class="line">    values_curr = np.zeros(states.shape)</span><br><span class="line">    max_diff = <span class="number">1e6</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        </span><br><span class="line">        values_curr = compute_state_bellman_equation(policy, p, values_curr)</span><br><span class="line">        max_diff = np.max(np.sqrt((values_next - values_curr)**<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> max_diff &lt; threshold:</span><br><span class="line">            <span class="keyword">return</span> values_curr</span><br></pre></td></tr></table></figure>
<p>일단 방법은 다음과 같다.</p>
<ol>
<li>두 개의 value matrix $V, V’$를 만든다. $V$는 현재 value function을 저장할 matrix, $V’$는 value function을 계산한 결과를 저장할 matrix이다.</li>
<li>State bellman equation $v_{\pi}(s)$을 통해 $V$만을 이용해서 $V’$를 계산한다.</li>
<li>$\epsilon = max|V - V’|^2$를 계산한다. 즉, 가장 value가 크게 변한 state를 찾는다.</li>
<li>어떤 작은 수 $\theta$에 대해 $\epsilon \leq \theta$이라면, value function이 충분히 수렴되었다고 간주하고 $V’$를 반환한다.</li>
<li>$\epsilon &gt; \theta$이라면, $V \leftarrow V’$로 대입하고 2번으로 돌아간다.</li>
</ol>
<h2 id="Policy-Control">Policy Control</h2>
<p>Policy control이란, 주어진 policy와 그것으로부터 만들어낸 value function을 가지고, optimal policy를 찾는 과정을 말한다.</p>
<h3 id="Policy-Improvement-Theorem">Policy Improvement Theorem</h3>
<p>Action value를 비교하는데, 현재 상태에서 액션을 원래 policy $\pi$에 따라 선택한 후, policy $\pi$를 따르는 action value를 $q_{\pi}(s, \pi(s))$라고 하자. 또, 같은 상태에서 액션을 다른 policy $\pi’$에 따라 선택한 후, 원래 policy $\pi$를 따르는 action value를 $q_{\pi}(s, \pi’(s))$라고 하자.</p>
<p>$q_{\pi} (s, \pi’(s)) \geq q_{\pi} (s, \pi(s))$를 만족하면, 적어도 $\pi’$는 $\pi$보다는 좋다라는 이론이다. 만약, 두 action value가 같다면, 이미 optimal일 확률이 높다.</p>
<p>위 이론에 따라, 현재 policy보다 좀 더 좋은 policy를 찾는 방법은, 주어진 value function에 따라 확률적으로 action을 선택하던 현재 policy를 greedy한 deterministic한 policy로 바꾸는 것이다.<br>
$$<br>
\pi’ = \underset{a}{\text{argmax} } \sum_{s’,r} p(s’,r|s,a)[r + \gamma \cdot v_{\pi}(s’)] ~ \text{(for all state } s\text{)}<br>
$$</p>
<h2 id="Policy-Iteration-Dynamic-Programming">Policy Iteration - Dynamic Programming</h2>
<p><strong>Optimal policy를 찾는 알고리즘</strong>으로, 다음과 같은 과정으로 이루어진다. 일단 어떤 state에서 어떤 액션을 취하면 어떤 immediate reward를 받는지는 이미 알고 있다고 가정한다. Immediate reward의 분포 $p(r|s)$은 exploration &amp; exploitation 으로 추정해야 하거나 개발자가 이미 정해놓거나?</p>
<ol>
<li>Initialize $\pi_0$. 즉, 최초의 policy를 만들고 이를 현재의 policy $\pi$로 삼는다. 최초의 policy는 아무거나로 한다. 모든 액션을 uniform distribution에 따라 선택하는 policy로 해도 된다.</li>
<li>Evaluate $\pi$. 즉, 주어진 policy에 대해 value function을 계산한다.</li>
<li>Control $\pi$. 즉, 계산된 value function을 바탕으로 모든 상태에서 greedy한 action을 선택하는 새로운 policy $\pi’$를 만든다.</li>
<li>$\pi’ = \pi$라면, $\pi$를 반환하고 끝낸다. 아니라면, $\pi$에  $\pi’$를 대입하고 2번으로 간다.</li>
</ol>
<p>이 과정을 통틀어서 policy iteration 방법이라고 부른다. 다음은 전체 pseudo code.</p>
<p><img src="https://raw.githubusercontent.com/wayexists02/my-study-note/image/typora/image/image-20200121183345364.png" alt="image-20200121183345364"></p>
<p>일단, 가장 처음 policy를 제외하고 이후 control에 의해 만들어진 모든 policy는 greedy하고 deterministic한 policy이다. 하지만, 이것은 새로 evaluate로 생성된 value function에서 greedy하지 않게 된다.</p>
<p>즉, evaluate과정을 거처서 만들어낸, 현 policy를 따르는 value function에서 현재 policy가 greedy하지 않게 되고,</p>
<p>control하는 과정을 거치면 greedy한 policy를 만들 수 있지만, 이건 또 다시 policy evalutation을 통해 더 좋은 policy가 있다는 것이 밝혀진다.</p>
<p>이 과정을 통해, 더 이상 좋은 policy가 없을 때 까지 수렴하게 된다.</p>
<p><img src="https://raw.githubusercontent.com/wayexists02/my-study-note/image/typora/image/image-20200121183703146.png" alt="image-20200121183703146"></p>
<h2 id="Generalized-Policy-Iteration">Generalized Policy Iteration</h2>
<p>Policy Iteration의 일반적인 형태.</p>
<p>앞서 나온 policy iteration은 policy evaluation과 control를 번갈아가면서 수행했다. 그리고, evaluation에서는 value function이 수렴할때까지 loop를 돌렸고, 수렴한 다음에야 policy control을 시행했다. Policy control 또한 완전한 greedy한 deterministic policy를 선택했다. 하지만, generalized policy iteration은 다음처럼 작동한다.</p>
<p><img src="https://raw.githubusercontent.com/wayexists02/my-study-note/image/typora/image/image-20200122120728463.png" alt="image-20200122120728463"></p>
<p>Policy evaluation은 loop를 돌지 않고 한번만 회전하고 policy control또한 조금 완화된 greedy action을 선택하게끔 한다.</p>
<h3 id="Value-Iteration">Value Iteration</h3>
<p>Generalized policy iteration의 한 방법으로, policy evaluation과 control를 번갈아서 수행하지 않고 evaluation을 policy와 관계없이 value값에 대해서만 수행해서 수렴시키고 control를 최종적으로 수행한다.</p>
<p><img src="https://raw.githubusercontent.com/wayexists02/my-study-note/image/typora/image/image-20200122121014540.png" alt="image-20200122121014540"></p>
<p>알고리즘은 위와 같은데, value funciton을 계산할 때, &quot;어떤 state에서는 무조건 이 액션을 선택해&quot;라고 말하는 policy를 넣지 않고, 그냥 value를 최대로 하는 액션을 선택하도록 한다. 그리고 그 최대 value로 업데이트한다. 이 과정을 반복하면 value function 혼자서 optimal에 수렴하게 되고 optimal value function을 이용해서 policy를 뽑아낸다.</p>
<h3 id="Asynchronous-Dynamic-Programming">Asynchronous Dynamic Programming</h3>
<p>한번 value function을 업데이트할때, 모든 state를 순차적으로 다 돌지 말고, 필요한 state에 대한 value만, 순서관계없이 업데이트하자는 것이라고 한다.</p>
<p>또한, 모든 state를 다 업데이트하는것이 아니라 관계있는 state들만 업데이트한다.</p>
<h3 id="Monte-Carlo-Methods">Monte Carlo Methods</h3>
<p>지금까지 dynamic programming을 통해 value function과 policy를 계산 및 추정했는데, dynamic programming을 통한 방법 외에도 여러가지 방법이 존재한다.</p>
<p>Monte carlo method는 하나의 state에 대해 각 액션을 많이 취해보고 Monte carlo estimation을 통해 value 추정값을 계산하자는 방법이다. 즉, 그 state에서 각각 액션을 많이 취해보고 얻은 reward들을 단순 평균내자는 이야기이다. 이 방법은 optimal policy를 매우 정확하게 찾을 것을 보장해준다.(단, action을 해서 reward를 한 trial이 많아야 한다.)</p>
<p>Monte carlo estimation의 단점은 모든 state에서 모든 액션을 많이 취해봐야 정확한 value function을 추정할 수 있는데, 그게 현실적으로 불가능하다.</p>
<h3 id="Brute-Force-Estimation">Brute-Force Estimation</h3>
<p>Brute-force 방법은 간단하다. 가능한 모든 deterministic policy 조합을 나열하고 그중에서 optimal policy를 찾는 것을 말한다. 이 방법 역시 optimal policy를 반드시 찾을 것을 보장해준다. 하지만, action수에 따라 가능한 policy 조합이 exponential하게 증가한다. 그래서 사실상 적용이 불가능하다.</p>

</div>


  <div class="book-comments">
    




  </div>


<script src="/js/book-post.js"></script>
        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="L"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Lee Jaeyoung</div>
      <div>2020-03-03</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/Study-Notes/">Study Notes</a> <a class="category-link" href="/categories/Study-Notes/Reinforcement-Learning/">Reinforcement Learning</a>

      <a class="tag-link" href="/tags/ReinforcementLearning/">#ReinforcementLearning</a> <a class="tag-link" href="/tags/StudyNotes/">#StudyNotes</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>

<script src="/js/book-toc.js"></script>
</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>

<script src="/js/book.js"></script>